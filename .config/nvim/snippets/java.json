{
"Normal CP Java": {
  "prefix": "boilerplate",
  "body": [
    "import java.io.*;",
    "import java.util.*;",
    "import java.math.*; // For BigInteger, BigDecimal if needed",
    "",
    "/**",
    " * Main class for Competitive Programming",
    " */",
    "public class Main { // Or Solution, or whatever your contest platform requires",
    "",
    "    // Fast I/O",
    "    static BufferedReader br;",
    "    static PrintWriter out;",
    "    static StringTokenizer st;",
    "",
    "    // Constants ( примеры - adjust as needed)",
    "    static final int MOD = 1_000_000_007; // 10^9 + 7",
    "    static final long INF_LONG = Long.MAX_VALUE / 2;",
    "    static final int INF_INT = Integer.MAX_VALUE / 2;",
    "    static final double EPS = 1e-9;",
    "",
    "    // Main method: Handles test cases and I/O setup",
    "    public static void main(String[] args) throws IOException {",
    "        br = new BufferedReader(new InputStreamReader(System.in));",
    "        // For potentially faster output, wrap System.out with BufferedWriter",
    "        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));",
    "",
    "        // To read the number of test cases",
    "        // int t = nextInt();",
    "        // while (t-- > 0) {",
    "        //     solve();",
    "        // }",
    "",
    "        // For a single test case",
    "        solve();",
    "",
    "        out.flush(); // Don't forget to flush output!",
    "        out.close();",
    "        br.close();",
    "    }",
    "",
    "    /**",
    "     * This is where you write the core logic for each test case.",
    "     * Helper methods for I/O are available (nextInt(), nextLong(), nextLine(), etc.).",
    "     * Print output using 'out.println()' or 'out.print()'.",
    "     */",
    "    static void solve() throws IOException {",
    "        // --------------- Your Code Starts Here --------------- //",
    "",
    "        // Example: Read two integers and print their sum",
    "        // int a = nextInt();",
    "        // int b = nextInt();",
    "        // out.println(a + b);",
    "",
    "        // Example: Read a string",
    "        // String s = next();",
    "        // out.println(\"Read string: \" + s);",
    "",
    "        // Example: Read a full line",
    "        // String line = nextLine();",
    "        // out.println(\"Read line: \" + line);",
    "",
    "        // Example: Read an array of integers",
    "        // int n = nextInt();",
    "        // int[] arr = nextIntArray(n);",
    "        // printArray(arr);",
    "",
    "",
    "        // --------------- Your Code Ends Here --------------- //",
    "    }",
    "",
    "    //********************************************************************************//",
    "    //*************************** INPUT HELPER METHODS *******************************//",
    "    //********************************************************************************//",
    "",
    "    static String next() throws IOException {",
    "        while (st == null || !st.hasMoreTokens()) {",
    "            String line = br.readLine();",
    "            if (line == null) { // Check for EOF",
    "                // You can throw an exception, return null, or handle as needed.",
    "                // For CP, often if input ends unexpectedly, it might be an error",
    "                // or the end of test cases if not explicitly given.",
    "                // Returning null can be a way to break a loop if input is exhausted.",
    "                return null;",
    "            }",
    "            st = new StringTokenizer(line);",
    "        }",
    "        return st.nextToken();",
    "    }",
    "",
    "    static int nextInt() throws IOException {",
    "        return Integer.parseInt(next());",
    "    }",
    "",
    "    static long nextLong() throws IOException {",
    "        return Long.parseLong(next());",
    "    }",
    "",
    "    static double nextDouble() throws IOException {",
    "        return Double.parseDouble(next());",
    "    }",
    "",
    "    static char nextChar() throws IOException {",
    "        String token = next();",
    "        if (token.length() != 1) {",
    "            throw new IOException(\"Expected a single character, but got: \" + token);",
    "        }",
    "        return token.charAt(0);",
    "    }",
    "",
    "    static String nextLine() throws IOException {",
    "        // This will read the entire line from the BufferedReader.",
    "        // If StringTokenizer 'st' had tokens from a previous partial read of a line,",
    "        // they are effectively discarded by br.readLine(), and st is reset by next().",
    "        // This is usually the desired behavior for reading a \"new line\".",
    "        String line = br.readLine();",
    "        if (line == null) { // Handle EOF",
    "            return null;",
    "        }",
    "        st = null; // Reset tokenizer as we've consumed a new line.",
    "        return line;",
    "    }",
    "",
    "    static boolean nextBoolean() throws IOException {",
    "        String s = next();",
    "        if (\"true\".equalsIgnoreCase(s) || \"1\".equals(s)) {",
    "            return true;",
    "        }",
    "        if (\"false\".equalsIgnoreCase(s) || \"0\".equals(s)) {",
    "            return false;",
    "        }",
    "        // Depending on problem constraints, you might throw an error or assume false",
    "        throw new IOException(\"Invalid boolean input: \" + s);",
    "    }",
    "",
    "    // Methods to read arrays",
    "    static int[] nextIntArray(int n) throws IOException {",
    "        int[] arr = new int[n];",
    "        for (int i = 0; i < n; i++) {",
    "            arr[i] = nextInt();",
    "        }",
    "        return arr;",
    "    }",
    "",
    "    static long[] nextLongArray(int n) throws IOException {",
    "        long[] arr = new long[n];",
    "        for (int i = 0; i < n; i++) {",
    "            arr[i] = nextLong();",
    "        }",
    "        return arr;",
    "    }",
    "",
    "    static double[] nextDoubleArray(int n) throws IOException {",
    "        double[] arr = new double[n];",
    "        for (int i = 0; i < n; i++) {",
    "            arr[i] = nextDouble();",
    "        }",
    "        return arr;",
    "    }",
    "",
    "    static String[] nextStringArray(int n) throws IOException {",
    "        String[] arr = new String[n];",
    "        for (int i = 0; i < n; i++) {",
    "            arr[i] = next();",
    "        }",
    "        return arr;",
    "    }",
    "",
    "    //********************************************************************************//",
    "    //*************************** OUTPUT HELPER METHODS ******************************//",
    "    //********************************************************************************//",
    "",
    "    // Use out.print(), out.println() directly.",
    "    // For custom array printing (if needed frequently):",
    "",
    "    static void printArray(int[] arr) {",
    "        for (int i = 0; i < arr.length; i++) {",
    "            out.print(arr[i] + (i == arr.length - 1 ? \"\" : \" \"));",
    "        }",
    "        out.println();",
    "    }",
    "",
    "    static void printArray(long[] arr) {",
    "        for (int i = 0; i < arr.length; i++) {",
    "            out.print(arr[i] + (i == arr.length - 1 ? \"\" : \" \"));",
    "        }",
    "        out.println();",
    "    }",
    "",
    "    static void printArray(double[] arr) {",
    "        for (int i = 0; i < arr.length; i++) {",
    "            out.print(arr[i] + (i == arr.length - 1 ? \"\" : \" \"));",
    "        }",
    "        out.println();",
    "    }",
    "",
    "    static void printArray(Object[] arr) {",
    "        for (int i = 0; i < arr.length; i++) {",
    "            out.print(arr[i] + (i == arr.length - 1 ? \"\" : \" \"));",
    "        }",
    "        out.println();",
    "    }",
    "",
    "    //********************************************************************************//",
    "    //***************************** DEBUGGING METHODS ********************************//",
    "    //********************************************************************************//",
    "",
    "    static void debug(Object... args) {",
    "        System.err.print(\"DEBUG: \");",
    "        for (int i = 0; i < args.length; i++) {",
    "            System.err.print(args[i]);",
    "            if (i < args.length - 1) {",
    "                System.err.print(\" \");",
    "            }",
    "        }",
    "        System.err.println();",
    "    }",
    "     static void debug(int[] arr) {",
    "        System.err.print(\"DEBUG: \");",
    "        System.err.println(Arrays.toString(arr));",
    "    }",
    "",
    "    static void debug(long[] arr) {",
    "        System.err.print(\"DEBUG: \");",
    "        System.err.println(Arrays.toString(arr));",
    "    }",
    "    // Add more debug overloads as needed (e.g., for 2D arrays, collections)",
    "",
    "",
    "    //********************************************************************************//",
    "    //**************************** OTHER UTILITY METHODS *****************************//",
    "    //********************************************************************************//",
    "",
    "    static long gcd(long a, long b) {",
    "        while (b != 0) {",
    "            long temp = b;",
    "            b = a % b;",
    "            a = temp;",
    "        }",
    "        return Math.abs(a); // Ensure positive GCD",
    "    }",
    "",
    "    static long lcm(long a, long b) {",
    "        if (a == 0 || b == 0) return 0;",
    "        return Math.abs(a * b) / gcd(a, b);",
    "    }",
    "",
    "    static long power(long base, long exp) {",
    "        long res = 1;",
    "        base %= MOD; // Apply modulo to base",
    "        while (exp > 0) {",
    "            if (exp % 2 == 1) res = (res * base) % MOD;",
    "            base = (base * base) % MOD;",
    "            exp /= 2;",
    "        }",
    "        return res;",
    "    }",
    "",
    "    static long modInverse(long n) {",
    "        return power(n, MOD - 2); // Using Fermat's Little Theorem (MOD must be prime)",
    "    }",
    "",
    "    // Add Sieve of Eratosthenes, sorting helpers, etc. if commonly used.",
    "}"
  ],
  "description": "Normal CP Java"
}
}
